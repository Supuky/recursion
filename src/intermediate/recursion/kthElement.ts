// k番目の要素 (できなかった)
// Smith は再帰的なプログラムを作成しました。このプログラムでは、最初の行には 0 を書き、それ以降の各行では前の行を見て、各 0 を 01 に、各 1 を 10 に置き換えます。行を表す n と、文字の位置を表す k（>0）が与えられるので、n 行目にある、k 番目の記号を返す、kthElement という関数を再帰を使って作成してください。

// 例えば、1 行目は 0、2 行目は 01、3 行目は 0110、4 行目は 01101001 のようになります。

// 関数の入出力例
// 入力のデータ型： integer n, integer k
// 出力のデータ型： integer
// kthElement(4,5) --> 1
// kthElement(2,1) --> 0
// kthElement(2,2) --> 1
// kthElement(4,6) --> 0
// kthElement(5,8) --> 1
// kthElement(7,31) --> 0
// kthElement(9,47) --> 0
// kthElement(9,102) --> 0


// k番目の要素の解説と解答
// わかりやすいように、n 行目の k 番目の数字を f(n,k) と表すことにします。まずは具体例で流れを見ていきましょう。まずは 3 行目までの数字を並べていきます。
// n 行目の偶数番目と奇数番目に着目しながら処理を見ていきます。

// まずは k が偶数のときを考えてみましょう。例えば、図のように f(3,2) は、f(2,1) の 0 に依存し、f(3,4) は、f(2,2) の 1 に依存しています。つまり、この関係性から k が偶数のとき、f(n,k) は f(n-1,k/2) が 0 か 1 かによって値が変わることがわかります。

// 同様に k が奇数のときも見てみます。f(3,1) は、f(2,1) の 0 に依存し、f(3,3) は、f(2,2) の 1 に依存しています。つまり、k が奇数のときは、f(n,k) は、f(n-1, (k+1)/2) が 0 か 1 にかによって値が変わります。

// つまり
// kが奇数の場合
// (3, 1)->(2, 1)に依存して(2, 1)と同じ0を返す
// (3, 3)->(2, 2)に依存して(2, 2)と同じ1を返す

// kが偶数の場合
// (3, 2)->(2, 1)に依存して(2, 1)とは違う数字の1を返す
// (3, 4)->(2, 2)に依存して(2, 2)とは違う数字の0を返す

// この関係を利用して値を求める方法をコードで表すと、以下のようになります。

function kthElement(n: number,k: number) {
  // 1行目の値は常に0です。
  if (n == 1) return 0;
  // k番目が偶数の時、前の行にあるk/2番目の要素を調べます。k番目の値は、前の行の要素が0の場合1、1の場合0になります。
  if (k % 2 == 0) {
      if (kthElement(n-1, k/2) == 0) return 1;
      else return 0;
  }
  // k番目が奇数の時、前の行にある(k+1)/2番目の要素を調べます。k番目の値は、前の行の要素が0の場合0、1の場合1になります。
  else {
      if(kthElement(n-1, (k+1)/2) == 0) return 0;
      return 1;
  }
}

console.log(kthElement(4,5));
console.log(kthElement(2,1));
console.log(kthElement(2,2));
console.log(kthElement(4,6));
console.log(kthElement(9,47));