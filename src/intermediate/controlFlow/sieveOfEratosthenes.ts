// キャッシュは、以前の計算結果を保存し、アルゴリズムが再計算する代わりにキャッシュから結果を取得できるようにすることで、アルゴリズムの性能を向上させるために使用されます。これは、同じデータが複数回必要な場合や、計算に時間がかかる場合に特に有効です。

// n 未満の全ての素数を少ない計算量で求めてみましょう。ここでは、エラトステネスのふるいと呼ばれる古典的なアルゴリズムを使用します。このアルゴリズムにはキャッシュが不可欠です。

// 整数 n 未満の全ての素数を求めるには、1 から N 未満の整数を順番に素数判定していくといったように全通り検索することで求めることができます。しかし計算量は O(N1.5)と遅く、N の値が大きいと非常に計算に時間がかかります。ここで、エラトステネスのふるいを使用することで効率的に求めることができます。

// エラトステネスのふるいでは、2 から与えられた数までのすべての数のリストを作成し、素数だけが残るまで、リスト内の各数のすべての倍数を消去していくことで動作します。例えば、2 を true としてマークし、その倍数 4, 6, 8, 10, 12, ... を false としてマークします。2 以外の 2 の倍数は、素数ではないからです。同様に 3 を true として、6, 9, 12, 15, 18, ... を false としてマークしていきます。

// 例えば、4 という数字がリスト中の他の数字の倍数であるかどうかを調べる場合、まずキャッシュをチェックして、この結果がすでに計算されていないかどうかを確認することができます。この場合、既に false としてマークされているため、8, 12, 16 ... のような数字を再度計算する必要はありません。このようにキャッシュを利用することで、再度計算を行う必要がなくなり、時間とリソースを大幅に節約することができます。

// このように順番にマークしていくことで、最終的に残った true が全て素数となります。エラトステネスのふるいは、以下のステップを行うことで実装することができます。

// 1). サイズ n のブール値 true のリストを生成します。

// 2). 最初の素数を 2 と設定します。

// 3). 1~n の中から 2 で割り切れるものを全て false にします。

// 4). 素数 3 に対しても同じ処理を行います。

// 5). これを √n まで繰り返します。

// 6). キャッシュ内に残った全ての真の値のインデックスは素数になります。

// エラトステネスのふるいのアルゴリズム
function allNPrimesSieve(n: number){
  // サイズnのブール値trueを持つリストを生成します。キャッシュ
  let cache = [];
  for(let i = 0; i < n; i++) {
      cache.push(true);
  }
  // console.log(cache)

  // ステップを√n回繰り返します。nが素数でないと仮定すると、n = a * bと表すことができるので、aとbの両方が√n 以上になることはありえません。
  // したがって、√n * √n = n は最大合成組み合わせになります。
  for (let currentPrime = 2; currentPrime < Math.ceil(Math.sqrt(n)); currentPrime++){
      // キャッシュ内の素数(p)の倍数をすべてfalseにしていきます。
      // iは2からスタートします。
      if (!cache[currentPrime]) continue;
      let i = 2;
      let ip = i * currentPrime;
      while (ip < n){
          cache[ip] = false;
          // i*pをアップデートします。
          i += 1;
          ip = i * currentPrime;
      }
  }

  console.log(cache)
  console.log(cache.length)

  // キャッシュ内のすべてのtrueのインデックスは素数です。
  let primeNumbers = [];
  for (let i = 2; i < cache.length; i++){
      if (cache[i]){
          primeNumbers.push(i);
      }
  }

  return primeNumbers;
}

console.log(allNPrimesSieve(100));
console.log((allNPrimesSieve(100).length));

// O( nloglogn) の時間計算量を持ちます。n 個のスロットが必要なので、O(n) の空間計算量を持っています。