二分ヒープ(1)
二分ヒープ（binary heap）は特別な種類の完全二分木で、特定のプロパティを満たす木構造です。この二分ヒープの特性は、任意の親ノードの値がその子ノードの値と等しく、またはそれより大きい（または小さい）ことです。これにより、最大ヒープ（親ノードが子ノードよりも値が大きい）または最小ヒープ（親ノードが子ノードよりも値が小さい）が形成されます。


二分ヒープには主に 2 つの種類があります。

最大ヒープ：根ノードが最大値となります。全てのノードは、その親ノードよりも小さい（または等しい）値を持ちます。
最小ヒープ：根ノードが最小値となります。全てのノードは、その親ノードよりも大きい（または等しい）値を持ちます。

注意点としては、この「親子間での大小関係」は兄弟ノード間には適用されないということです。つまり、兄弟ノードの間には値の大小についての制約がないということです。


また、ヒープは完全二分木であるという性質を持っています。これは全ての階層が左から右へ順に埋まっている状態を指します。そのため、ヒープは配列としても表現でき、データの追加や削除が高速に行えるのが特徴です。


さらに、二分ヒープはその特性上、高性能な優先度付きキューの実装やヒープソートという高速なソートアルゴリズムの基盤として使用されます。優先度付きキューは、データを優先度に応じて取り出すことが可能なデータ構造で、ヒープはその効率的な実装を可能にします。

ここでの「ヒープ」はプログラミングにおける「ヒープメモリ」の概念とは異なるものなので注意が必要です。「ヒープメモリ」は動的にメモリを割り当てたり解放したりするための領域を指します。「ヒープメモリ」はメモリの動的確保を行う場所で、プログラムの実行中に必要になった時にメモリを確保し、不要になった時に解放します。ここでいう「ヒープ」はメモリの管理方法を示すものであり、二分ヒープというデータ構造とは全く関係がないという点に注意が必要です

最後に、二分ヒープは「in-place」ソートを実現します。これは、ソートを行う際に新たなメモリ領域をほとんど確保することなく、配列内で要素の位置を交換することによりソートを行う手法です。これにより、メモリ使用量を抑えつつ高速にソートを行うことが可能となります。この特性により、ヒープソートは非常に効率的なソートアルゴリズムとされています。

二分ヒープ(2)
二分ヒープは特定のプロパティを持つ完全二分木です。これは、全ての層がノードで満たされ、最下層の葉ノードが可能な限り左に寄せられている木のことを指します。この性質のおかげで、二分ヒープは配列として表現することが可能です。


配列での表現方法を見てみましょう。配列のインデックスはノードの位置関係を表すことができます。配列の 0 番目の位置は根ノードに対応し、その後、インデックスが増えるにつれて木の階層が深まり、左から右へとノードが埋まっていきます。

根ノードを 0 とし、幅優先で以下のように番号を順に降ってみましょう。

二分ヒープは完全二分木であることから、配列のインデックスを i とすると、次のような規則があります。

i 番目のノードの左の子ノード: left(i) = 2i + 1
i 番目のノードの右の子ノード: right(i) = 2i + 2
i 番目のノードの親ノード: parent(i) = floor((i-1) / 2)


二分ヒープの例
例えば、[10,14,19,26,31,42,27,44,35,33] のような配列があった場合、インデックス0（根ノード）の値は 10 で、その子ノードは 14 と 19 です。これは left(0) = 1, right(0) = 2 から、arr[1] = 14, arr[2] = 19 を取り出すことができます。


同様に、インデックス 3 の値は 26 で、その子ノードは 44 と 35 になります。これは left(3) = 7, right(3) = 8 から、 arr[7] = 44, arr[8] = 35 を取り出すことができます。

さて、ヒープにおいては、特定のプロパティ（最大ヒープの場合は親ノードが子ノードより大きい、または等しいというプロパティ）を維持するための操作が重要です。これを行うのが Max-Heapify 関数です。Max-Heapify 関数は、あるノードとその子ノードがヒープのプロパティを満たさない場合に、それを修正します。具体的には、親ノードが子ノードより小さい場合、親ノードと最大の子ノードを交換します。

Max-Heapify
Max-Heapify は、最大ヒープというデータ構造を維持するための重要な関数です。最大ヒープとは、親ノードがその子ノードよりも大きい、あるいは等しいという性質を持つ二分木のことを指しました。Max-Heapify は、あるノードとその子ノードが最大ヒープのルールを守るように、必要に応じてノード間のデータを入れ替える処理を行います。


次のようなステップで進められます。

Max-Heapify は、ある特定のノード（ノード i）を起点に行われます。そのノード i が、自分自身とその子ノードの中で最大の値を持つことを確認します。
もしノード i が最大の値を持っていたら、何もせず終了です。これは最大ヒープのルールを守っているからです。
しかし、もしノード i が子ノードよりも小さい値を持っていたら、そのノード i と、最大の値を持つ子ノードを交換します。この交換のことを「スワップ」と言います。

このスワップによって、ノード i は最大値を持つようになり、一旦は最大ヒープのルールを守ることができます。しかし、スワップによって移動した子ノードは、新しい場所での最大ヒープのルールを守れているか確認が必要です。

そのため、スワップで移動した子ノードに対して、再度 Max-Heapify を行います。つまり、その子ノードが新しい場所で最大値を持つことを確認し、必要であればさらにスワップします。

これを、すべてのノードが最大ヒープのルールを守るようになるまで繰り返します。


maxHeapifyの実装
maxHeapify は、以下のように実装することができます。

def maxHeapify(arr, i):
    # 左と右の子ノードのインデックスを取得します
    l = heap.left(i)
    r = heap.right(i)

    # まずは親ノード（自分自身）を最大値と仮定します
    biggest = i

    # 自分、左の子、右の子の中で最大の値を持つものを探します
    # 左の子が最大値を持つなら、そのインデックスを保存します
    if(arr[l] > arr[biggest]): 
        biggest = l

    # 右の子が最大値を持つなら、そのインデックスを保存します
    if(arr[r] > arr[biggest]): 
        biggest = r

    # 自分が最大でなければ、最大の子と位置を入れ替え（スワップ）します
    if(biggest != i):
        # スワップは、一時的な変数（ここではtemp）を使って行います
        temp = arr[i]
        arr[i] = arr[biggest]
        arr[biggest] = temp
        
        # スワップにより子ノードの位置が変わったので、その子ノードに対して再びmaxHeapifyを実行します
        # これにより、全体として最大ヒープの性質を維持します
        heap.maxHeapify(arr,biggest)

では、Max-Heapify を実装してみましょう。

// Heapクラスは二分ヒープを操作するためのクラスです。
class Heap {
    static left(i) {
        // 左の子ノードのインデックスを計算します。0から始まるインデックスを使用します。
        return 2 * i + 1;
    }

    static right(i) {
        // 右の子ノードのインデックスを計算します。0から始まるインデックスを使用します。
        return 2 * i + 2;
    }

    // 最大ヒープを構築します。つまり、あるノードとその子ノードが条件を満たさない場合に、そのノードを再配置します。
    static maxHeapify(arr, i) {
        // この条件は、親ノードがその子ノードよりも大きいか等しいというものです。
        // 左の子ノードのインデックスを取得します。
        const l = Heap.left(i);
        // 右の子ノードのインデックスを取得します。
        const r = Heap.right(i);

        // 最大値のインデックスを保存します。初期値は親ノードのインデックスです。
        let biggest = i;
        // 子ノードが存在し、それが親ノードよりも大きい場合、最大値のインデックスを更新します。
        if (l < arr.length && arr[l] > arr[biggest]) biggest = l;
        if (r < arr.length && arr[r] > arr[biggest]) biggest = r;

        // 親ノードが最大値でなければ、親ノードと最大値を交換し、再度ヒープ構築を行います。
        if (biggest !== i) {
            const temp = arr[i];
            arr[i] = arr[biggest];
            arr[biggest] = temp;
            Heap.maxHeapify(arr, biggest);
        }
    }
}

// ヒープの例を示し、maxHeapifyメソッドを使ってそれが最大ヒープになるように調整します。
const heap1 = [2, 42, 11, 30, 10, 7, 6, 5, 9];
// 根ノードが2で、2 < 42のため、最大ヒープではありません。
Heap.maxHeapify(heap1, 0);
console.log(heap1);

const heap2 = [56, 4, 51, 10, 12, 5, 12, 4, 6, 5];
// インデックス1が4で、4 < 10のため、最大ヒープではありません。
Heap.maxHeapify(heap2, 1);
console.log(heap2);

Max-Heapify の計算量
Max-Heapify 操作の時間計算量は、O(
log
n
) です。これは、配列内の要素の交換を行う回数に比例するため、繰り返し回数に応じた計算量になります。


最悪の場合、根ノードが最も深い葉ノードと交換されるようなケースが考えられます。この場合、計算量はヒープの高さ h に比例し、O(
h
) となります。完全二分木では、n 個の葉ノードを持つ場合、ヒープの高さは 
log
2
n
 になるため、計算量は O(
log
n
) となります。


一方、各要素はその場でスワップ（交換）されるため、Max-Heapify の空間計算量は O(1) となります。つまり、追加のメモリスペースは必要ありません。

最大ヒープの構築
前の項では、maxHeapify を作成しました。


この関数は、特定のノードについてヒープの性質を維持または修復します。具体的には、与えられたノードの位置で、親ノードがその子ノードよりも大きい（または等しい）という最大ヒープの性質が保たれていることを確認します。これが保たれていない場合、親ノードと最大の子ノードを交換します。そして交換が発生した子ノードについて再帰的に同じ処理を行います。ただし、この関数は単独では配列全体を最大ヒープにすることはできません。


ここで、配列全体を最大ヒープに変換する buildMaxHeap という関数を作成しましょう。配列の中央から始めて、配列の先頭（根ノード）に向かって maxHeapify 関数を各ノードに適用します。これにより、配列全体が最大ヒープの性質を満たすようになります。

ヒープは完全二分木であるため、配列で表現した場合、その半分以上は葉ノードになります。そして、葉ノードはそれ自体でヒープの条件を満たしています。なぜなら葉ノードには子ノードがないため、「親ノードが子ノードより大きい」というヒープの条件を満たすことが自動的に保証されるからです。


したがって、ヒープ化の処理（maxHeapify 関数の適用）を始める最初のポイントとして配列の中央を選ぶことになります。これは、配列の中央から左（配列の先頭方向）にある全ての要素が葉ノードではなく、子ノードを持つノードであり、これらが最大ヒープの条件を満たすか確認し、必要なら修正する必要があるからです。


配列の中央から右（配列の末尾方向）にある要素（葉ノード）はすでにヒープの条件を満たしているため、これらに対する処理は必要ありません。


buildMaxHeap の実装
buildMaxHeap 関数は、以下のように実装できます。

// buildMaxHeapアルゴリズムの実装
function buildMaxHeap(arr) {
    // 配列の中央位置を計算
    middle = parent(arr.length)
    
    // 中央位置から先頭までループを実行
    for(let i = middle; i >=0; i--) {
        // maxHeapify関数を呼び出してヒープ化を行う
        maxHeapify(arr, i)
    }
}
以下で、配列 arr を受け取り、配列の状態をその場で更新し、最大ヒープ化する buildMaxHeap という関数を作成してください。

class Heap{
    static left(i){
        return 2*i + 1;
    }

    static right(i){
        return 2*i + 2;
    }
    
    static parent(i){
        return Math.floor((i-1) / 2);
    }    

    static maxHeapify(arr, i){
        let l = Heap.left(i);
        let r = Heap.right(i);

        let biggest = i;
        if(l < arr.length && arr[l] > arr[biggest]) biggest = l;
        if(r < arr.length && arr[r] > arr[biggest]) biggest = r;

        if(biggest != i){
            let temp = arr[i];
            arr[i] = arr[biggest];
            arr[biggest] = temp;
            Heap.maxHeapify(arr,biggest);
        }
    }

    // buildMaxHeapを実装します。
    static buildMaxHeap(arr){
        let middle = Heap.parent(arr.length)
        // 最後の葉ノードの親ノードから根ノードまで maxHeapfy します。
        for(let i = middle; i >=0; i--){
            Heap.maxHeapify(arr,i);
        }    
    } 
}   

let heap1 = [2,42,11,30,10,7,6,5,9];
console.log(heap1);
Heap.buildMaxHeap(heap1);
// 根ノードが最大値となり木全体が最大ヒープになりました。
console.log(heap1); // 42, 30, 11, 9, 10, 7, 6, 5, 2

let heap2 = [56,4,51,10,12,5,12,4,6,5];
console.log(heap2);
Heap.buildMaxHeap(heap2);
console.log(heap2); // 56, 12, 51, 10, 5, 5, 12, 4, 6, 4

buildMaxHeap 関数の計算量
単純に考えると、この buildMaxHeap 関数の全体の計算量は O(nlogn) となりそうです。なぜなら、n 個の要素それぞれに対して、最悪の場合 logn の操作が必要だからです。


しかし、ヒープの性質上、高さが深いノード（つまり、子ノードが多いノード）は少数しかなく、大部分のノードは高さが浅いです。したがって、全体の計算量は実際には O(n) となります。


これは、配列の要素を半分ずつ処理していくため、
logn 回のヒープ化操作が必要な要素（根ノード）は 1 つ、log(n2) 回の操作が必要な要素（その子ノード）は 2 つ、...と続き、1 回の操作が必要な要素は n/2 個となります。これを合計すると、合計の操作回数は n となります。

ヒープソート
ヒープソートと呼ばれるソート（並べ替え）のアルゴリズムを見てみましょう。ヒープソートは、特定の性質を持つ二分ヒープというデータ構造を用いて、データをソートします。

最大ヒープの作成: まず、与えられたデータから最大ヒープを作成します。この段階では、最大値がヒープの根に位置します。例えば、配列 [4, 10, 3, 5, 1] を最大ヒープに変換すると [10, 5, 3, 4, 1] のような形になります。
最大値の取り出しと交換: ヒープから最大値を取り出します。最大値は常に根に位置するため、これを直接取り出すことが可能です。そして、この最大値と最後の葉ノード（配列でいうと一番最後の要素）を交換します。前述の例で言うと、最大値 10 と一番最後の要素 1 を交換して、[1, 5, 3, 4, 10] となります。
最大値の削除: 次に、最大値をヒープから削除します。実際には要素を物理的に削除するわけではなく、ヒープとして考慮する範囲を 1 つ狭めることで実現します。先ほどの例でいうと、最大値の 10 をヒープから取り除いたと考え、ヒープとしては [1, 5, 3, 4] となります。
ヒープの再構成: ヒープから最大値を削除した結果、ヒープの性質が崩れる可能性があります。そのため、maxHeapify を行い、再び最大ヒープになるように調整します。例えば、先ほどの [1, 5, 3, 4] に対して maxHeapify を行うと、再び最大値が根に来るように [5, 4, 3, 1] となります。
繰り返し: これらの手順をヒープのサイズが 1 になるまで繰り返します。ヒープのサイズが 1 ということは、ヒープに含まれる要素が 1 つだけという意味で、それ以上ソートすべき要素がないということを意味します。繰り返しの過程で、最大値がヒープから取り出されて配列の末尾に置かれていくため、配列全体がソートされます。

たとえば、最初の配列が [4, 10, 3, 5, 1] だったとすると、ヒープソートの過程を通じて次のように変化します。

最初の最大ヒープ: [10, 5, 4, 3, 1]
最大値の取り出しと交換、ヒープの再構成後: [5, 4, 3, 1] と 10
最大値の取り出しと交換、ヒープの再構成後: [4, 1, 3] と 5, 10
最大値の取り出しと交換、ヒープの再構成後: [3, 1] と 4, 5, 10
最大値の取り出しと交換、ヒープの再構成後: [1] と 3, 4, 5, 10
最大値の取り出しと交換、ヒープの再構成後: [] と 1, 3, 4, 5, 10

ヒープソートの実装
ヒープソートは、以下のように実装することができます。

def heapSort(arr):
    # まず、与えられた配列から最大ヒープを構築します。
    buildMaxHeap(arr)

    # ヒープの終端を表すheapEndを定義し、初期値として配列の長さ - 1を設定します。
    # これは、配列全体が最初のヒープであることを示しています。
    heapEnd = len(arr) - 1

    # heapEndが0より大きい限り（ヒープのサイズが1以上）繰り返します。
    while(heapEnd > 0):
        # 最大値（ヒープの根）と最後の葉ノードを交換します。
        # これにより、最大値が配列の最後に移動します。
        temp = arr[heapEnd]
        arr[heapEnd] = arr[0]
        arr[0] = temp

        # ヒープから最大値を"削除"します。具体的にはヒープの範囲を1つ狭めることで実現します。
        heapEnd -= 1

        # 最大値を削除した後、ヒープの性質が崩れてしまう可能性があるため、
        # maxHeapifyを用いて再び最大ヒープを構成します。
        maxHeapify(arr, heapEnd, 0)

ヒープソートの計算量
ヒープソートでは、n 個の要素を対象に、maxHeapify の呼び出しと最大値の取り出し（スワップ）を行います。maxHeapify は一度の呼び出しにつき O(logn) の時間がかかるので、これを合計 n 回行うため、合計の時間計算量は O(nlogn) となります。これは、n 個の要素をソートするために必要な時間が、要素の数 n に対して、対数時間 logn がかかることを示しています。


また、ヒープソートは、基本的に与えられた配列内で要素の交換を行うだけなので、追加のメモリをほとんど必要としません。空間計算量は O(1) になります。

class Heap{
    static left(i){
        return 2*i + 1;
    }

    static right(i){
        return 2*i + 2;
    }
    
    static parent(i){
        return Math.floor((i-1) / 2);
    }    

    // ヒープのサイズを追跡するために maxHeapify を拡張します
    static maxHeapify(arr, heapEnd ,i){
        let l = Heap.left(i);
        let r = Heap.right(i);
        let biggest = i;

        // heapEnd より後ろはすでにソートされているので、l と　r のインデックスは heapEnd までを比較します。
        if(l <= heapEnd && arr[l] > arr[biggest]) biggest = l;
        if(r <= heapEnd && arr[r] > arr[biggest]) biggest = r;
    
        if(biggest != i){
            let temp = arr[i];
            arr[i] = arr[biggest];
            arr[biggest] = temp;
            Heap.maxHeapify(arr, heapEnd ,biggest);
        }
    }

    static buildMaxHeap(arr){
        let middle = Heap.parent(arr.length)
        for(let i = middle; i >= 0; i--){
            Heap.maxHeapify(arr, arr.length-1, i);
        }    
    }

    // ヒープソートを実装します。
    static heapSort(arr){
        // まずは buildMaxHeap で arr をヒープ構造にします。1番上は最大値になっています。
        Heap.buildMaxHeap(arr);

        // ヒープサイズを追跡するため heapEnd を配列の最後の要素にします。
        let heapEnd = arr.length - 1;
        while(heapEnd > 0){
            //  最大値であるヒープの根ルートと葉ノード heapEnd を入れ替えます。
            let temp = arr[heapEnd];
            arr[heapEnd] = arr[0];
            arr[0] = temp;

            //　一番最後はソートされているので、heapEnd から 1 引きます。
            heapEnd--;
            Heap.maxHeapify(arr, heapEnd, 0);
        }    
    }          
}

let heap1 = [2,42,11,30,10,7,6,5,9];
console.log(heap1);
Heap.heapSort(heap1);
console.log(heap1); // 昇順にソートされました。

let heap2 = [56,4,51,10,12,5,12,4,6,5];
console.log(heap2);
Heap.heapSort(heap2);
console.log(heap2);

優先度付きキュー(1)
ヒープは、特定の順序でデータを効率的に管理するためのデータ構造で、優先度付きキューの実装によく使われます。


優先度付きキュー（priority queue）とは、要素が優先度順に格納されるキューのことを指します。要素はその優先度に基づいて追加され、最も高い優先度を持つ要素が最初に取り出されます。


具体的な操作としては、

top(): 最も高い優先度を持つ要素を取得します。
insert(x): 要素 x を優先度に基づいて適切な位置に挿入します。
pop(): 最も高い優先度を持つ要素をキューから取り除き、その要素を返します。
といったものがあります。

二分ヒープとは、特定の性質を満たす特殊な木構造のデータ構造で、ヒープ全体が特定の順序（最大または最小）を保持するように構築されました。この性質により、二分ヒープは優先度付きキューの効率的な実装を可能にします。


具体的には、top() はヒープの根を直接参照できるため、O(1) で実行できます。一方、insert() や pop() はヒープの再構築を必要とするため、それぞれ O(
log
n
) の時間計算量が必要となります。


最大ヒープを使用すると、最大値を持つ要素が常に根に位置します。これは、例えば最大値を優先するスケジューリングやアクセス制御のようなアプリケーションで役立ちます。一方、最小ヒープでは最小値を持つ要素が常に根に位置します。これは、例えばイベント駆動型アプリケーションで役立ちます。ここではイベントがキューに追加され、そのイベントの発生予定時刻（つまり最小値）が来るまで待つという流れになります。

Note:

通常のキューは、FIFO（First In First Out: 最初に入ったものが最初に出る）の原則に基づいています。つまり、要素は一番後ろに追加され、取り出しは一番前から行われます。この操作はいずれも通常 O(1) の時間計算量で可能です。しかし、優先度に基づいて特定の要素を探す場合、全ての要素を順に検査する必要があるため、その操作は O(
n
) の時間計算量となります。


優先度付きキューでは、要素はその優先度に応じて追加・取り出されます。最も一般的な実装方法はヒープを用いる方法で、これにより優先度の高い要素を効率的に見つけ出すことが可能となります。要素の追加や最大（最小）要素の取り出しは、通常 O(
log
n
) の時間計算量で、最大（最小）要素の参照は、O(1) の時間計算量で可能です。

優先度付きキューを使用する利点は、要素を追加や取り出すたびに全体をソートする必要がないという点にあります。その代わり、ヒープでは一部の要素を適切な位置に移動するだけで、データの整頓を保つことができます。これは、データが動的に変化するシチュエーション、例えば新しい要素が頻繁に追加される場合や、最大（最小）の要素が頻繁に取り出される場合に特に効果的です。

優先度付きキュー(2)
pop メソッド
ヒープで最高優先度の値（最大値または最小値）にアクセスするには、根ノードを参照するだけで良いです。しかし、この最高優先度の値を削除（pop）する際には、ヒープの性質を保つための特定の手順を踏む必要があります。


まず、最高優先度の値は根ノードにあるため、このノードの値を削除します。しかし、ただ削除するだけでは木の構造が壊れてしまいますので、何かしらの方法でこの穴を埋める必要があります。


一般的な方法は、ヒープの最後の葉ノード（配列で表現されている場合は最後の要素）を根ノードの位置に移動することです。この操作により、一旦木構造は保たれますが、ヒープの性質（最大ヒープの場合、親ノードは常にその子ノード以上の値を持つという性質）が壊れてしまう可能性があります。


そこで、新たな根ノードを中心にヒープ化の処理（maxHeapify）を行います。この処理では、新たな根ノードの値がその子ノードの値よりも小さい場合、最大値の子ノードと位置を交換し、その子ノードを新たな根にして再度ヒープ化の処理を行う、という操作を再帰的に繰り返します。これにより、ヒープ全体が再度ヒープの性質を満たすようになります。


この操作の時間計算量は O(
log
n
) となります。これは、二分ヒープが完全二分木であるため、ノードの高さ（根ノードからの距離）が 
log
n
 で表され、それが最大の操作回数となるためです。

def pop(heapArr):
    # 最優先度の値（根ノード）を保存
    popped = heapArr[0]

    # ヒープの最後の葉ノードを根ノードの位置に移動
    heapArr[0] = heapArr[heapArr.length-1]

    # ヒープから最後の葉ノード（現在の根ノードの値がここにある）を削除
    heapArr.pop()

    # 新たな根ノードから maxHeapify を呼び出すことで、ヒープ全体を再ヒープ化
    # heapArr.length-1 はヒープの現在の長さ（最後の葉ノードが削除された後）
    # 0 は新たな根ノードのインデックス
    maxHeapify(heapArr, heapArr.length-1, 0)

    # 最優先度の値（削除された根ノードの値）を返す
    return popped

では、pop() メソッドを PriorityQueue 構造に追加してみましょう。


insert メソッド
insert 関数は、新しい値 x を優先度キュー（最大ヒープ）に追加するための方法です。具体的な手順は以下の通りです。

まず、x をヒープの最後（末尾）に追加します。
次に、x がその親ノードより大きい場合は、x と親ノードとの間でスワップ（交換）を行います。これは、最大ヒーププロパティ（親ノードが子ノードよりも大きい）を維持するためです。
x がその新しい親ノードより小さくなるか、もしくは x が根ノード（ヒープの頂点）に達するまで、上記のスワップを繰り返します。
これらの手順は、「sifting up」と呼ばれます。これは、新しく追加された値 x がヒープ内で適切な位置になるまで、根ノードに向かって「上昇」していく様子を表しています。


この操作の時間計算量は O(
log
n
) です。これは、ヒープは完全二分木であるため、最悪の場合でもヒープの深さ（根ノードから最も遠い葉ノードまでの距離）は 
log
n
 となるからです。したがって、新しい値が適切な位置に到達するために必要なスワップの最大回数も 
log
n
 となります。


# insert関数を定義します。これは最大ヒープ(maxHeap)と要挿入する値(x)を引数に取ります。
def insert(maxHeap, x):
   # 値xをヒープの最後に追加します。
   maxHeap.push(x)

   # ヒープの最後の要素のインデックスを取得します。これは新しく追加した値xのインデックスです。
   i = maxHeap.length-1

   # iの親ノードのインデックスを取得します。
   parent = parent(i)

   # 親が存在し、かつ、親の値がxより小さい場合はループを続けます。このループでは、xが親よりも大きい限り、xと親とをスワップします。
   while(parent >= 0 && maxHeap[parent] < x):
      # 値xと親ノードの値をスワップするため、まずxの値を一時変数tempに保存します。
      temp = maxHeap[i]

      # xの位置に親ノードの値をセットします。
      maxHeap[i] = maxHeap[parent]

      # 親ノードの位置に保存しておいたxの値（temp）をセットします。これによりxと親ノードの値とがスワップされます。
      maxHeap[parent] = temp

      # xが親ノードとスワップされたので、xの新しいインデックスとして親ノードのインデックスを設定します。
      i = parent;

      # 新しい親ノードのインデックスを取得します。次のループでこの親ノードとxとを比較します。
      parent = parent(i)
insert 関数をサポートするように、PriorityQueue 構造を拡張してください。


class HeapLibrary{

    static buildMaxHeap(arr){
        let mid = HeapLibrary.parent(arr.length-1);
        for(let i = mid; i >= 0; i--){
            HeapLibrary.maxHeapify(arr, arr.length-1, i);
        }
    }

    static maxHeapify(arr, heapEnd, i){
        let l = HeapLibrary.left(i);
        let r = HeapLibrary.right(i);

        let biggest = i;

        if(l <= heapEnd && arr[l] > arr[biggest]) biggest = l;
        if(r <= heapEnd && arr[r] > arr[biggest]) biggest = r;
        
        if(i !== biggest){
            let temp = arr[i];
            arr[i] = arr[biggest];
            arr[biggest] = temp;
            HeapLibrary.maxHeapify(arr, heapEnd, biggest); 
        }
    }

    static left(i){
        return 2*i + 1;
    }

    static right(i){
        return 2*i + 2;
    }

    static parent(i){
        return Math.floor((i-1)/2);
    }    
}

class PriorityQueue{
    constructor(arr){

        this.maxHeap =  [...arr];
        HeapLibrary.buildMaxHeap(this.maxHeap);
    }

    top(){
        return this.maxHeap[0];
    }

    pop() {
        let popped = this.maxHeap[0];
        this.maxHeap[0] = this.maxHeap[this.maxHeap.length -1];
        this.maxHeap.pop();
        HeapLibrary.maxHeapify(this.maxHeap, this.maxHeap.length-1, 0)
        return popped;
    }

    insert(x){
        this.maxHeap.push(x)
        let i = this.maxHeap.length-1;
        let parent = HeapLibrary.parent(i);
        while(parent >= 0 && this.maxHeap[parent] < x){
            let temp = this.maxHeap[i];
            this.maxHeap[i] = this.maxHeap[parent];
            this.maxHeap[parent] = temp;
            i = parent;
            parent = HeapLibrary.parent(i);
        }    
    }        
}

let pq = new PriorityQueue([2,3,43,2,53,6,75,10]);
console.log(pq.maxHeap);
pq.insert(5)
console.log(pq.maxHeap);
pq.insert(5)
console.log(pq.maxHeap);
pq.insert(79)
console.log(pq.maxHeap);
pq.pop();
console.log(pq.maxHeap);