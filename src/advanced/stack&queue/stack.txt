スタック（stack）は、LIFO（Last-In-First-Out）の原則に従った線形データ構造です。スタックに追加された最後の要素が、最初に削除される要素と一致しました。

スタックは配列や連結リストを使用して実装され、幅広い用途で使用されます。スタックの一般的な用途の 1 つは、プログラミング言語における関数呼び出しの実装です。関数が呼び出されると、その引数とローカル変数がスタックに「プッシュ」され、関数が戻ると、これらの値がスタックから「ポップ」されます。スタックはまた、式の解析や評価といったタスクのアルゴリズムにも使用され、リスト内の要素の順序を逆転させるために使用されることもあります。

では実際にスタックの実装を見てみましょう。

class Node{
    constructor(data){
        this.data = data;
        this.next = null;
    }
}

class Stack{
    constructor(){
        this.head = null;
    }

    push(data){
        let temp = this.head;
        this.head = new Node(data);
        this.head.next = temp;
    }

    pop(){
        if(this.head == null) return null;
        let temp = this.head;
        this.head = this.head.next;
        return temp.data;
    }

    peek(){
        if(this.head === null) return null;
        return this.head.data;
    }
}

let s = new Stack();

s.push(2);
console.log(s.peek());

s.push(4);
s.push(3);
s.push(1);
console.log(s.pop());
console.log(s.peek());

時と場合によっては、開発者はスタックに限定されたデータ構造だけを使う時もあります。このように、ある一定のルールを決めて開発をすることがあるということを覚えておきましょう。

スタックのユニークな構造を使って、配列を逆表示する方法を考えてみましょう。前方から全ての要素をスタック内に一度 push し、そこから順に pop させると、要素を逆の順番で取り出すことができます。


スタックとは、最後に入れた物が最初に出てくるようなデータの保管方法です。これは、「最後に入れたものを最初に使う」という要求がある場合に役立ちます。例えば、一つの動きを戻したい時や、前の状態に戻りたい時などに使われます。


ゲームやアプリの「元に戻す」ボタンは良い例です。ここで行った操作をスタックに積んでおき、元に戻す時は最後の操作から取り出して消去します。したがって、直近の操作を撤回することが可能になります。


また、バックトラック（やり直し）のアルゴリズムにも使われます。これは、「いくつかの選択肢から正解を見つける」時によく使われます。すべての選択肢を試し、正解が見つからないときは一つ前の選択に戻り、別の選択肢を試します。これを可能にするのがスタックで、行った経路を保存しておき、戻る時は最後に試した選択肢から取り出します。

スタックの使用例
例えば、単調減少している最後の部分配列を取り出すには、整数で構成される配列を受け取り、スタックを使用します。スタックは、常に最新の要素を参照することができ、その値と配列の各要素を比較することができます。元となる配列として、[4, 3, 7, 6, 2, 8] を考えてみましょう。


アルゴリズムの手順は以下の通りです。

空のスタックを作成します。
例：stack = []
配列の各要素を順番に処理します。この例では最初の要素は 4 です。
currentElement = 4
スタックが空であるか、現在の要素がスタックの先頭の要素よりも小さい場合、現在の要素をスタックに追加します。
stack = [4]（スタックが空だったため、4 を追加）
それぞれの次の要素（3, 7, 6, 2）を同じ方法で処理します。ただし、7 の場合はスタックの先頭の要素 3 より大きいので、スタックが空になるまでスタックの先頭の要素を取り出し、その要素を単調減少している部分配列の一部として取得します。そして、7 をスタックに追加します。
stack = [4, 3] から stack = [7] になり、単調減少部分配列は [4, 3]
配列の処理が終了したら、8の場合もスタックの先頭の要素 2 より大きいので、スタックが空になるまでスタックの先頭の要素を取り出し、それらを単調減少している部分配列の一部として取得します。そして、8 をスタックに追加します。
stack = [7, 6, 2] から stack = [8] になり、単調減少部分配列は [7, 6, 2]
このアルゴリズムを使用すると、配列から単調減少する最後の部分配列（この例では [7, 6, 2] ）が取り出されます。スタックを使用することで、常に最新の要素を参照し、その値と配列の各要素を比較することができます。これにより、指定した条件に一致する部分配列を効率的に特定することが可能です。

class Node{
    constructor(data){
        this.data = data;
        this.next = null;
    }
}

class Stack{
    constructor(){
        this.head = null;
    }

    push(data){
        let temp = this.head;
        this.head = new Node(data);
        this.head.next = temp;
    }

    pop(){
        if(this.head == null) return null;
        let temp = this.head;
        this.head = this.head.next;
        return temp.data;
    }

    peek(){
        if(this.head === null) return null;
        return this.head.data;
    }
}

// リストを受け取り、単調減少している部分リストを返す関数を実装します。
// リストの途中で単調増加する部分が出現したら、部分リストをリセットします。
function consecutiveWalk(arr){
    let stack = new Stack();
    stack.push(arr[0]);
    for(let i = 1; i < arr.length; i++){
        // スタックの上にある要素より、arr[i]が大きい場合、スタックをリセットします。
        if(stack.peek() < arr[i]){
            // スタックがnullになるまで繰り返されます。
            while(stack.pop() != null);
        }
        // スタックにプッシュします。スタックは常に単調減少になっています。
        stack.push(arr[i]);
    }
    let results = [];
    // resultsは逆向きになっています。
    // unshiftは、preappendのようなもので、配列の先頭に追加します。
    while(stack.peek() != null) results.unshift(stack.pop());
    return results;
}

console.log(consecutiveWalk([3,4,20,45,56,6,4,3,5,3,2])); // [5,3,2]
console.log(consecutiveWalk([4,5,4,2,4,3646,34,64,3,0,-34,-54])); // [64,3,0,-34,-54]
console.log(consecutiveWalk([4,5,4,2,4,3646,34,64,3,0,-34,-54,4])); // [4]

https://recursionist.io/dashboard/problems/412
https://recursionist.io/dashboard/problems/296
https://recursionist.io/dashboard/problems/189
https://recursionist.io/dashboard/problems/245



スタックは、ソフトウェア開発でかなりの頻度で登場するので、しっかり練習してマスターしましょう。

Note: スタックの応用（中上級者向け HARD）

文字列で与えられた数学の式をスタックを使って計算することを考えてみましょう。まず、具体的な数学の式として、"7+3*2" を考えてみましょう。これを計算すると、答えは 13 になります。 この計算を行うために、二つのスタック、つまり「演算子スタック」と「オペランドスタック」を使います。以下にその流れを具体的に説明します。
式を左から読んでいき、最初の数字 "7"をオペランドスタックに追加します。オペランドスタックは今 [7]となります。
"+" を演算子スタックに追加します。演算子スタックは今 ["+"] となります。
"3" をオペランドスタックに追加します。オペランドスタックは今 [7, 3] となります。
"*" は、既に演算子スタックにある "+" よりも優先順位が高いので、そのままスタックに追加します。演算子スタックは今 ["+", "*"] となります。
最後の数字 "2" をオペランドスタックに追加します。オペランドスタックは今 [7, 3, 2] となります。
すべての数値と記号を読み終わったら、演算子スタックから最上部の "*" を取り出し、それに対応するオペランドスタックから最上部の "2" と "3" を取り出して掛け算を行い、結果 "6" をオペランドスタックに追加します。オペランドスタックは今 [7, 6]、演算子スタックは ["+"] となります。
次に、演算子スタックから最上部の "+" を取り出し、それに対応するオペランドスタックから最上部の "6" と "7" を取り出して足し算を行い、結果 "13" をオペランドスタックに追加します。オペランドスタックは最終的に [13] となります。


Note: 括弧の追加（上級者向け）

括弧を考慮する場合、括弧内の式を優先的に計算するため、演算子スタックに括弧を追加します。例えば、"(7+3)*2"という式があるとします。手順は以下の通りです。

最初のトークンは "(" なので、これを演算子スタックにプッシュします。演算子スタックは現在 ["("] です。
"7" をオペランドスタックにプッシュします。オペランドスタックは [7] です。
"+" を演算子スタックにプッシュします。演算子スタックは ["(", "+"] です。
"3" をオペランドスタックにプッシュします。オペランドスタックは [7, 3] です。
次に ")" を見つけます。これは、"(" が見つかるまで演算子スタックから演算子をポップし、それに対応するオペランドを計算することを意味します。"+" をポップし、"3" と "7" をポップして足し算を行い、その結果 "10" をオペランドスタックにプッシュします。オペランドスタックは [10]、演算子スタックは ["("] です。そして "(" もポップします。
次に "*" を演算子スタックにプッシュします。演算子スタックは ["*"] です。
最後に "2" をオペランドスタックにプッシュします。オペランドスタックは [10, 2] です。
すべてのトークンを処理したので、"*" をポップし、オペランドスタックから "2"と "10" をポップして掛け算を行い、その結果 "20" をオペランドスタックにプッシュします。オペランドスタックは [20] となり、これが答えになります。
このように、括弧を使う場合でも、演算子スタックとオペランドスタックを使って計算を進めることができます。